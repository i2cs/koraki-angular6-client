/**
 * Koraki API v1.0
 * Contains public API endpoints. Invoking sequred APIs require either Bearer token (auth token created when logging in to admin UI) or Basic digest (using client id and client secret of an application). If invoked with auth token, you need to pass `applicationId` with requests to identify the application.
 *
 * OpenAPI spec version: v1.0
 * Contact: madusha@koraki.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiErrorModel } from '../model/apiErrorModel';
import { NotificationCreateDataModel } from '../model/notificationCreateDataModel';
import { NotificationViewDataModel } from '../model/notificationViewDataModel';
import { PageResultNotificationViewDataModel } from '../model/pageResultNotificationViewDataModel';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class NotificationsService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates a new notification
     * 
     * @param notificationModel Notification model
     * @param applicationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createNotification(notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'body', reportProgress?: boolean): Observable<NotificationViewDataModel>;
    public createNotification(notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationViewDataModel>>;
    public createNotification(notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationViewDataModel>>;
    public createNotification(notificationModel?: NotificationCreateDataModel, applicationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('ApplicationId', <any>applicationId);
        }

        let headers = this.defaultHeaders;

        // authentication (Basic) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<NotificationViewDataModel>(`${this.basePath}/api/v1.0/Notifications`,
            notificationModel,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing notification
     * 
     * @param id Notification id
     * @param applicationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteNotification(id: number, applicationId?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteNotification(id: number, applicationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteNotification(id: number, applicationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteNotification(id: number, applicationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteNotification.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('ApplicationId', <any>applicationId);
        }

        let headers = this.defaultHeaders;

        // authentication (Basic) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/api/v1.0/Notifications/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a list of notifications of application identified by application id
     * 
     * @param statuses Notification statuses to filter
     * @param pageSize 
     * @param pageNumber 
     * @param applicationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllNotifications(statuses?: Array<'Created' | 'Processing' | 'Ready' | 'Hidden' | 'Removed'>, pageSize?: number, pageNumber?: number, applicationId?: string, observe?: 'body', reportProgress?: boolean): Observable<PageResultNotificationViewDataModel>;
    public getAllNotifications(statuses?: Array<'Created' | 'Processing' | 'Ready' | 'Hidden' | 'Removed'>, pageSize?: number, pageNumber?: number, applicationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageResultNotificationViewDataModel>>;
    public getAllNotifications(statuses?: Array<'Created' | 'Processing' | 'Ready' | 'Hidden' | 'Removed'>, pageSize?: number, pageNumber?: number, applicationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageResultNotificationViewDataModel>>;
    public getAllNotifications(statuses?: Array<'Created' | 'Processing' | 'Ready' | 'Hidden' | 'Removed'>, pageSize?: number, pageNumber?: number, applicationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (statuses) {
            statuses.forEach((element) => {
                queryParameters = queryParameters.append('Statuses', <any>element);
            })
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('PageNumber', <any>pageNumber);
        }
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('ApplicationId', <any>applicationId);
        }

        let headers = this.defaultHeaders;

        // authentication (Basic) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageResultNotificationViewDataModel>(`${this.basePath}/api/v1.0/Notifications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets single notification identified by notification id
     * Includes basic application data.
     * @param id Notification id
     * @param applicationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getNotificationById(id: number, applicationId?: string, observe?: 'body', reportProgress?: boolean): Observable<NotificationViewDataModel>;
    public getNotificationById(id: number, applicationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationViewDataModel>>;
    public getNotificationById(id: number, applicationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationViewDataModel>>;
    public getNotificationById(id: number, applicationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getNotificationById.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('ApplicationId', <any>applicationId);
        }

        let headers = this.defaultHeaders;

        // authentication (Basic) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationViewDataModel>(`${this.basePath}/api/v1.0/Notifications/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing notification
     * 
     * @param id Notification id
     * @param notificationModel Notification model
     * @param applicationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateNotification(id: number, notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateNotification(id: number, notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateNotification(id: number, notificationModel?: NotificationCreateDataModel, applicationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateNotification(id: number, notificationModel?: NotificationCreateDataModel, applicationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateNotification.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (applicationId !== undefined && applicationId !== null) {
            queryParameters = queryParameters.set('ApplicationId', <any>applicationId);
        }

        let headers = this.defaultHeaders;

        // authentication (Basic) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // authentication (Bearer) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/api/v1.0/Notifications/${encodeURIComponent(String(id))}`,
            notificationModel,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
