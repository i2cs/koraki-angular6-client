/**
 * Koraki API v1.0
 * Contains public API endpoints. Invoking sequred APIs require either Bearer token (auth token created when logging in to admin UI) or Basic digest (using client id and client secret of an application). If invoked with auth token, you need to pass `applicationId` with requests to identify the application.
 *
 * OpenAPI spec version: v1.0
 * Contact: madusha@koraki.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiErrorModel } from '../model/apiErrorModel';
import { NotificationPublicViewDataModel } from '../model/notificationPublicViewDataModel';
import { NotificationViewDataModel } from '../model/notificationViewDataModel';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class WidgetService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Gets all public notifications of an application identified by the key
     * This is a public call and header authorization is not required
     * @param key Application key (Client Id)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAll(key?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationViewDataModel>>;
    public getAll(key?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationViewDataModel>>>;
    public getAll(key?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationViewDataModel>>>;
    public getAll(key?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationViewDataModel>>(`${this.basePath}/Widget/v1.0/public`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Customization data from application client id
     * This is a public call and header authorization is not required
     * @param key Application key (Client Id)
     * @param r Random number to clear server cache
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAnalyticsId(key?: string, r?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationViewDataModel>>;
    public getAnalyticsId(key?: string, r?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationViewDataModel>>>;
    public getAnalyticsId(key?: string, r?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationViewDataModel>>>;
    public getAnalyticsId(key?: string, r?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }
        if (r !== undefined && r !== null) {
            queryParameters = queryParameters.set('r', <any>r);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationViewDataModel>>(`${this.basePath}/Widget/v1.0/data`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Loads the widget js
     * 
     * @param key Key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public js(key: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public js(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public js(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public js(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling js.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/javascript'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Widget/v1.0/js/${encodeURIComponent(String(key))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Live analytics data of visitors
     * This is a public call and header authorization is not required
     * @param key Application key (Client Id)
     * @param meta Page meta data as a json object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public liveVisitors(key?: string, meta?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationPublicViewDataModel>>;
    public liveVisitors(key?: string, meta?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationPublicViewDataModel>>>;
    public liveVisitors(key?: string, meta?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationPublicViewDataModel>>>;
    public liveVisitors(key?: string, meta?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (key !== undefined && key !== null) {
            queryParameters = queryParameters.set('key', <any>key);
        }
        if (meta !== undefined && meta !== null) {
            queryParameters = queryParameters.set('meta', <any>meta);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationPublicViewDataModel>>(`${this.basePath}/Widget/v1.0/live`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
